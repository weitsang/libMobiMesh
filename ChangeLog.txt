2011 05 31
----------
- UI Updates
  * Meshes now loaded on demand, per format, and unloaded when a different mesh
    (not different format, different mesh, like thai vs horse) is loaded.
  * User may capture more than one view at a time for each mesh and choose
    which one to load
  * Captured views are saved upon program exit.
  * Fixed activity spinner bug using proper threading. Now, mesh loading takes
    place in the background rather than main thread (previously, it sometimes
    shows up and sometimes does not disappear)
  * However, there seems to be a bug that occurs once in a while, report
    EXC_BAD_ACCESS when a mesh loads.

- ZPM and rendering implementation
  * ZPM rendering implemented for both 32 and 64 bit.
  * GLMeshRendererFactory is able to create ZPM meshes.
  * Rendering can be done using both ES1.1 and ES2.
  * Framerate improved by displaying a coarse mesh until the viewpoint stops
    changing, then calling the adapt() method to refine the mesh.

- VPM rendering modified
  * Same technique for rendering ZPM is applied to VPM rendering, i.e. display
    coarse mesh until viewpoint stops changing.

- Optimization
  * Instead of creating a new container object when passing the geometry data
    (points, vertices, normals) to the renderer, a const pointer is returned
    to the internal container.
  * This is to avoid copying these large structures each time the VBO needs to
    be updated (costly).
  * Framerates have improved by about 1-2fps as a result.

- Mesh rotation problem fixed
  * Previously, some meshes do not rotate about the center.
  * This has been fixed by fixing the method that returns the center of the
    mesh (it was incorrectly implemented previously).

- TODO from prev entry
  * Transfer ZPM code. -- Done
  * Improve frame rate and performance. -- Not doing
    - Capture a sequence of views (as generated by the user touch screen input)
    - Replay this view and profile all renderers against it.
  * Do not have duplicate storage of vertices, normals and faces. -- Done
  * Improve the frame rate by making the underlying containers of the mesh
    classes more suitable for glDrawArrays (so we don't have to repack).
    -- Done
  * Consider replacing std::vector with simple C arrays to save on memory.
    -- On hold
  * GLMeshRendererFactory's memory management needs to be tested. -- Not done.

- TODO
  * Consider replacing std::vector with simple C arrays to save on memory.
    -- On hold
  * Fix EXC_BAD_ACCESS bug when loading meshes.
  * Fix mmap()'s ENOMEM error when loading some meshes.


2011 05 16
----------
- UI Updates
  * Capture/Load view buttons added to store the modelview matrix of the
    current mesh's view and to load the same view on the same mesh rendered
    in different format.
  * Meshes are loaded on demand.
  * Added activity indicator/spinner when mesh is loading.
  * Added label to indicate current mesh being rendered
  * Added UI to list all meshes available so user can jump to different meshes.

- Vertex limit set back to 0xFFFF
  * To keep framerate reasonable. Code to render beyond 0xFFFF is still there.

- TODO from prev entry
  * Improve frame rate and performance. -- On hold
    - Capture a sequence of views (as generated by the user touch screen input)
    - Replay this view and profile all renderers against it.
  * Do not have duplicate storage of vertices, normals and faces. -- On hold
  * Improve the frame rate by making the underlying containers of the mesh
    classes more suitable for glDrawArrays (so we don't have to repack).
    -- On hold
  * Consider replacing std::vector with simple C arrays to save on memory.
    -- On hold
  * GLMeshRendererFactory's memory management needs to be tested. -- On hold.

- TODO
  * Transfer ZPM code.
  * Improve frame rate and performance. -- On hold
    - Capture a sequence of views (as generated by the user touch screen input)
    - Replay this view and profile all renderers against it.
  * Do not have duplicate storage of vertices, normals and faces. -- On hold
  * Improve the frame rate by making the underlying containers of the mesh
    classes more suitable for glDrawArrays (so we don't have to repack).
    -- On hold
  * Consider replacing std::vector with simple C arrays to save on memory.
    -- On hold
  * GLMeshRendererFactory's memory management needs to be tested. -- On hold.


2011 05 10
----------
- Renderers may render more than 0xFFFF vertices now.
  * If number of vertices <= 0xFFFF, we use glDrawElements. Anything more than
    that we use glDrawArrays.
  * The underlying mesh representation has to return faces as
    std::vector<unsigned int> to be able to store sufficiently many faces.
  * This type is not supported by glDrawElements. Thus, when drawing a small
    mesh, the faces need to be repacked into std::vector<unsigned short>
  * The underlying mesh representation also does not store the mesh in a
    method that glDrawArrays can use directly.
  * Repacking needs to be done even when using glDrawArrays. This can cause
    the frame rate to drop drastically especially when there are many
    vertices/faces.

- Changed class design of GLMeshRenderer*
  * Previously had 2 classes GLMeshRenderer and GLMeshRendererES2, for
    rendering using OpenGL ES 1.1 and 2.0 respectively.
  * GLMeshRenderer is now an abstract base class for any renderer using
    OpenGL's VBO in rendering. It implements IMeshRenderer.
  * It defines pure virtual methods which subclasses must implement. These
    methods define how the modelview and projection matrices should be setup,
    how the vertex pointers and vertex normals are setup, etc.
  * Reason for this is that the steps to rendering using OpenGL ES's VBO is
    similar regardless of version so we do not want to duplicate these steps
    across 2 different classes.
  * Subclasses GLMeshRendererES1 and GLMeshRendererES2 implement these abstract
    methods accordingly by calling the appropriate OpenGL ES methods.

- Changed class design of GLVpmMeshRenderer
  * Previously had a vpm renderer class for each OpenGL ES version, each
    inheriting from GLMeshRendererES* depending on the version.
  * Now, these classes are placed into 1 single class GLVpmMeshRenderer that
    implements IMeshRenderer directly and uses GLMeshRenderer to do the
    rendering.
  * Reason for this is that the code in both vpm mesh renderer classes from
    before were exactly the same, except that they called the render()
    method of different base classes.
  * Now, the single GLVpmMeshRenderer class takes a GLMeshRenderer* object
    and calls it's render() method when it needs to render.
  * The vpm renderer is now independent of OpenGL ES version, and it is left
    to the caller to supply the appropriate GLMeshRenderer* object.

- Updated GLMeshRendererFactory to reflect class design changes
  * Factory now returns IMeshRenderer* instead of GLMeshRenderer* and
    GLMeshRendererES2*.
  * It also creates the appropriate GLMeshRenderer* when creating a
    GLVpmMeshRenderer*
  * Since the factory is allocating renderer objects, it is also responsible
    for deleting them.
  * For ease of memory management, we limit the number of renderer objects that
    can be created to a constant MAX_RENDERERS.
  * There is also a free_mesh_renderer method so that callers may free up
    renderers that it is no longer using, and the factory can create more
    renderers.

- Added UI to MobiMesh project
  * UI involves a left and right arrow to go to the prev/next mesh.
  * Meshes and their renderers are loaded all at once when the program starts
    so it is a bit slow when starting up.

- Implemented Trackball rotation
  * Math taken from: http://viewport3d.com/trackball.htm

- TODO from prev entry
  * Improve frame rate and performance. -- Not done (got slower in fact)
    - Capture a sequence of views (as generated by the user touch screen input)
    - Replay this view and profile all renderers against it.
  * Fix trackball rotation. -- Done
  * Do not have duplicate storage of vertices, normals and faces. -- Not done
  * Increase number of renderable vertices beyond sizeof(GLsizei) by allowing
    multiple calls to glDrawElements per frame. -- Done
  * Add UI to allow users to load mesh. -- Done (not to load mesh, but to view
    prev/next mesh)

- TODO
  * Improve frame rate and performance.
    - Capture a sequence of views (as generated by the user touch screen input)
    - Replay this view and profile all renderers against it.
  * Do not have duplicate storage of vertices, normals and faces.
  * Improve the frame rate by making the underlying containers of the mesh
    classes more suitable for glDrawArrays (so we don't have to repack).
  * Consider replacing std::vector with simple C arrays to save on memory.
  * GLMeshRendererFactory's memory management needs to be tested.


2011 05 03
----------
- Fixed rotation problem where upon rotating the mesh 180 degrees about the
  x-axis, rotations about the y-axis become in reverse direction
  * This is done by keeping track of the modelview matrix directly (as opposed
    to calling glTranslate, glRotate, etc. calls.
  * For the ES1.1 renderer, the modelview matrix is supplied using glMultMatrix
  * For the ES2 renderer, the "lookat" and "transformation" uniform variables
    have been combined into a single "modelview" uniform variable.
  * This modelview matrix is stored in GLMeshRendererViewingParameters.
  * Each time a rotation is made, it is made directly to the modelview matrix,
    which is made up of "lookat" and "transformation" matrices, the former
    to setup the camera, the latter to transform the object.
  * For example, if a rotation is done, the transformation matrix is
    pre-multiplied by the rotation matrix. The intuition is that the object
    should be further rotated from where it currently is.
  * Previous accessors to getting the current translation/scale/rotation values
    were removed since transformations are now performed incrementally instead.

- Added touchscreen capabilities to the OpenGLES11Renderer and
  OpenGLES2Renderer sample code.

- Double tapping the screen sets the mesh back to the default view.
  * This is done in the OpenGLES11Renderer and OpenGLES2Renderer sample code.

- Profiling of OpenGLES2Renderer (while using touchscreen)
  * Framerate is measured by having user manually rotate/scale mesh via
    touch screen and might be inconsistent across different application
    instances.
  * Framerate when rendering PM 6-7fps
  * Framerate when rendering VPM 3-5fps
  * Bottleneck seems to be coming from glDrawElements (16.5%)
  * Library related bottle necks are in
    ViewDependentProgressiveMesh::adaptive_refinement(),
    with outside_view_frustum() and qrefine() being the most expensive.

- Trackball rotation partially implemented (but buggy)
  * To support smoother rotation, trackball rotation is used.
  * This is stored in the Trackball class.
  * However, the implementation has bugs - there seems to be an issue with
    mapping the 2D screen coordinates to object space.

- TODO from prev entry
  * Improve frame rate and performance. -- Not done
    - Capture a sequence of views (as generated by the user touch screen input)
    - Replay this view and profile all renderers against it.
  * Consider writing a renderer engine (with support for lighting, texturing,
    etc. as in the iPhone 3D Programming book) -- Not writing
  * Consider using/supporting techniques like render to texture. -- Not for now
  * Do not have duplicate storage of vertices, normals and faces. -- Not done
  * More unit tests where possible.

- TODO
  * Improve frame rate and performance.
    - Capture a sequence of views (as generated by the user touch screen input)
    - Replay this view and profile all renderers against it.
  * Fix trackball rotation.
  * Do not have duplicate storage of vertices, normals and faces.
  * Increase number of renderable vertices beyond sizeof(GLsizei) by allowing
    multiple calls to glDrawElements per frame.
  * Add UI to allow users to load mesh.

2011 04 26
----------
- Added specular, diffuse and ambient lighting in samples and shaders.
  * These material parameters were added to the OpenGLES2Renderer shader.
  * Material parameters were originally setup on the OpenGLES11Renderer
    but done incorrectly. For OpengGL ES, the first argument to glMaterialfv
    should always be GL_FRONT_AND_BACK. It was previously GL_FRONT.

- All renderers (Generic, VPM, ES1.1 and ES2) no longer fix a viewport size.
  * Was previously set to the iPhone dimensions 320x480.
  * Now passed in as an argument to the renderer constructors (with default
    being 320x480 if dimensions were not supplied).
  * The same arguments are required of methods in GLMeshRendererFactory.
  * Similarly, if these dimensions are not supplied in the argument of the
    methods in the factory, it is default to 320x480.

- TODO from previous entry
  * Improve frame rate and performance. -- Not done
    - Incorporate latest VPM code if possible.
    - Check CPU performance bottle necks.
    - Duplicate storage of vertices/normals/faces might be a problem because
      copy constructor is called each time these params are accessed by the
      renderer, and these vectors are rather large.
  * Do not have duplicate storage of vertices, normals and faces. -- Not done
  * More unit tests where possible. -- Not done

- TODO
  * Improve frame rate and performance.
    - Capture a sequence of views (as generated by the user touch screen input)
    - Replay this view and profile all renderers against it.
  * Consider writing a renderer engine (with support for lighting, texturing,
    etc. as in the iPhone 3D Programming book)
  * Consider using/supporting techniques like render to texture.
  * Do not have duplicate storage of vertices, normals and faces.
  * More unit tests where possible.


2011 04 20
----------
- Fixed lighting problem.
  * Previously forgot to enable [back face] culling and depth test.
  * Now enabled when initializing the view controller.
  * Mesh renders correctly now (with correct lighting/normals).

- Used VBOs in GLMeshRendererES2
  * Used VBOs for mesh rendering as opposed to vertex array.
  * Improves frame rate for rendering VPM, but does not seem to have effect on
    rendering PM.

- Profiling (for graphics and cpu performance)
  * Using xcode's profile option.
  * For each profiling run, the view changes each frame as follows:
    - If scale > 0.7, reduce scale by 0.1
    - Rotate about both x,y axes by 1 degree
  * Frame rate for ES1.1 VPM, PM, ES2.0 VPM are approximately 7-8fps.
  * Frame rate for ES2.0 PM is approximately 3-4fps.
  * Frame rates are much lower than those reported using the latest VPM code.
  * Before using VBOs (profiled for ES2.0), frame rates for both PM and VPM
    were at 3-4fps.
  * Note that the lighting setup is slightly different between the ES1.1 and
    ES2.0 version. ES2.0 did not setup diffuse and material parameters.

- TODO from previous entry
  * Make use of VBOs in rendering. -- Done
  * Improve lighting. -- Done
  * Do not have duplicate storage of vertices, normals and faces. -- Not done
  * More unit tests where possible. -- Not done

- TODO
  * Improve frame rate and performance.
    - Incorporate latest VPM code if possible.
    - Check CPU performance bottle necks.
    - Duplicate storage of vertices/normals/faces might be a problem because
      copy constructor is called each time these params are accessed by the
      renderer, and these vectors are rather large.
  * Do not have duplicate storage of vertices, normals and faces.
  * More unit tests where possible.


2011 04 19
----------
- Modified GLMeshRendererES2 shader uniform variables.
  * Previously, the scale, dx, dy, angle_x, angle_y factors were exposed
    directly to the shaders and it was up to the shaders to work out the
    transformation matrices.
  * Now, the renderer computes 3 matrices and supplies it to the shader via
    the uniform variables. These 3 matrices are the projection, lookat and
    transformation matrix. The final position of each vertex can be computed
    using projection * lookat * transformation * position[in object space].

- Incorporated GLM library.
  * OpenGL ES 2.0 no longer supports functions like glRotate, glTranslate, etc.
  * GLM library is able to compute these matrices so we use the library to
    compute it, multiply matrices together, and supply the resulting matrices
    to the shaders via uniform variables.

- Implemented GLVpmMeshRendererES2.
  * VPM can be rendered now, with the view updated accordingly.
  * The current view is assumed to be the lookat * transformation matrix.
  * However, this might not be accurate because the user of the library
    might have ignored the lookat/transformation matrices supplied by the
    renderer object and work out his/her own view matrix to take a different
    view instead.

- Improved lighting
  * Previously toon shading not done nicely because the normal vector was not
    computed correctly.
  * Instead of using the normal vector in eye space, we were using the normal
    vector in object space.
  * This has been changed. The shader computes the normal vector in eye space
    using transpose(inverse(lookat * transformation)) * normal_object_space
  * The toon shading has improved but there are still parts of the mesh that
    are not being shaded correctly.

- TODO from previous entry
  * Make use of VBOs in rendering. -- Not done
  * Implement ES2 renderer for VPM. -- Done
  * Improve lighting. -- Partially done
  * Do not have duplicate storage of vertices, normals and faces. -- Not done
  * More unit tests where possible. -- Not done

- TODO
  * Make use of VBOs in rendering.
  * Improve lighting
  * Do not have duplicate storage of vertices, normals and faces.
  * More unit tests where possible.


2011 04 14
----------
- Fixed GLMeshRendererES2 problems.
  * Projection matrix has been fixed. Problem was a confusion between column
    major and row major matrices for OpenGL, transposing the matrix fixed it.
  * Vertex normals incorporated. There is some lighting being done by the
    shader now, but it is not very nicely done and can be improved.
  * The way lighting is done is to pass the vertex normal to the fragment
    shader which then computes the color intensity at each point based on the
    light direction.
  * Rendering has been tested on both simulatr and device (iOS 4.2)

- Added x,y rotation, x,y translation and uniform scaling to GLMeshRendererES2.
  * Shaders can use uniform variables to use these params set by users of the
    class.
  * Shaders have to perform the matrix computations themselves using these
    variables.

- TODO from previous entry
  * OpenGL ES 2.0 rendering: -- Done
    - Fix projection matrix problem.
    - Make use of the vertex normals.
  * Do not have duplicate storage of vertices, normals and faces. -- Not done
  * More unit tests where possible. -- Not done

- TODO
  * Make use of VBOs in rendering.
  * Implement ES2 renderer for VPM.
  * Improve lighting.
  * Do not have duplicate storage of vertices, normals and faces.
  * More unit tests where possible.

2011 04 12
----------
- Fixed bug in ViewDependentProgressiveMesh
  * Garbage collector code was not transferred properly. Re-copied it so it is
    fixed now.
  * Also, due to laziness, I have decided to expose draw_faces_, points_ and
    vertex_normals_ to subclasses of the ProgressiveMesh class.
  * This is for the garbage collector. Where possible, all other methods
    accessing specific geometry data via the handles should be done via the
    get_vertex/face/etc(handle) methods.

- Implemented OpenGL ES 2.0 Renderer: GLMeshRendererES2
  * Compiles vertex and fragment shaders.
  * Links the shaders into a program.
  * Sets up modelview and projection uniform variables (shaders should declare
    them, but need not use them). However, there seems to be a bug with the
    projection matrix setup.
  * Does not support vertex normals yet, so the rendered mesh is simply a bunch
    of white vertices.

- Moved renderers' viewing parameters into GLMeshRendererViewingParameters
  * Viewing parameters include the panning/rotation/scaling variables and also
    the points, normals and faces.
  * This is so that renderers can share these parameters (as well as methods
    that work on them, e.g. compute_view_parameters()) easily without having to
    duplicate code.

- Added sample projects in Samples group
  * The samples here should be read with the tutorial.
  * PMRenderer: Rendering a standard progressive mesh.
  * VPMRenderer: Rendering a view-dependent progressive mesh.
  * OpenGLES2Renderer: Rendering using OpenGL ES 2.0 - partially done.

- TODO from previous entry
  * ViewDependentProgressiveMesh is still NOT working. Somehow adapt() does not
    cause the points/normals/faces to be updated correctly so this needs to
    be fixed. -- Done (due to garbage_collection)
  * Fix bugs, add more unit tests (esp for new classes), and test on device.
    -- Unit tests not added, tested on device. Works on iOS 4.2
  * Because the mesh and renderer classes are separated, the list of vertices,
    normals and faces are stored separately in each class. This is
    ***BAD BAD BAD*** for memory usage. Will fix this to let both classes
    share the buffer for storing these rendering params.
    -- Not done.

- TODO
  * OpenGL ES 2.0 rendering:
    - Fix projection matrix problem.
    - Make use of the vertex normals.
  * Do not have duplicate storage of vertices, normals and faces.
  * More unit tests where possible.

2011 03 29
----------
- Implemented ViewDependentProgressiveMesh class (incorporating newest version
  of code)
  * Basically transferred impl over, and where necessary, some methods were
    factored into the ProgressiveMesh base class (e.g. parts of the garbage
    collection)
  * Also, code that accesses edges/vertices/etc. stored in the base class is
    changed to use protected base class methods.
    E.g. instead of edges[heh >> 1].halfedges[(heh >> 1) & 1],
    we simply use get_halfedge(heh);
  * Refactored code is still buggy, i.e. not working.

- Added GLVpmMeshRenderer class
  * Since rendering a VPM is different from rendering a standard mesh, in that
    we need to get the current view and then adapt the mesh, this calls for a
    specific renderer class to handle VPM rendering.
  * This inherits from GLMeshRenderer since mesh rendering code using OpenGL is
    re-usable.

- Regarding controller class
  * The controller class will not be part of the library (because functionality
    of the controller depends a lot on what the application is supposed to do)
  * Instead, it will remain as part of the application in
    MobiMeshViewController.mm
  * UI code for rotating/scaling/panning/etc. has been implemented in this
    class. However, rotate/scale/translate values are stored in the renderer
    class, which the controller must update, so that the renderer can setup
    the view appropriately before rendering.

- Added GLMeshRendererFactory
  * This namespace consists of a single function to get a GL mesh renderer
    object. The mesh' filename is supplied as an argument, and based on its
    extension, the appropriate renderer is created and returned.
  * For a .pm file, GLMeshRenderer is used.
  * For a .vpm file, GLVpmMeshRenderer is used.
  * These are however, transparent to the method's caller.
  * Users of the returned renderer object can simply call the render() method
    (without having to know the renderer/mesh type) in order to render the
    mesh.

- Added unit tests
  * Currently only contains test cases for ProgressiveMesh's
    new_face/vertex/edge methods.

- Added exception classes (this was in last week but not documented)
  * All exceptions thrown by methods in libMobiMesh extend from
    MobiMeshException which in turn extends std::exception.
  * Points in the code which previous exited upon error have been changed to
    throw an exception instead.

- TODOs from last week
  * Test the implementation (unit test, simulator, and device).
    - Some basic unit tests done.
    - Tested on simulator with .pm files, works
    - Not tested on device
  * Implement view controller class - this will contain the touch screen
    related methods currently stored in the FirstTryViewController.mm file in
    the newest code, e.g. touchesBegan, touchesMoved, etc.
    - See above (Decided to leave implementation inside
      MobiMeshViewController.mm)
  * Implement vdpm class.
    - Done but totally buggy (see next section)

- TODO
  * ViewDependentProgressiveMesh is still NOT working. Somehow adapt() does not
    cause the points/normals/faces to be updated correctly so this needs to
    be fixed.
  * Fix bugs, add more unit tests (esp for new classes), and test on device.
  * Because the mesh and renderer classes are separated, the list of vertices,
    normals and faces are stored separately in each class. This is
    ***BAD BAD BAD*** for memory usage. Will fix this to let both classes
    share the buffer for storing these rendering params.

2011 03 22
----------

- Implemented ProgressiveMesh class (incorporating newest version of code)
  * Newer version includes a different method signature for the vertex split
    operation. Now, vertex split operation must take in the two edge handles
    of the edges connecting the vertex to be split to the cut vertices.
  * Factored out a method build_loop, used in the vertex split operation, that
    builds a loop of edges between the vertex to be split and its cut edge.
  * View dependent mesh related variables and methods are not included in the
    implementation in this class, e.g. list of "free" vertices/faces (for
    re-use since vdpm can create/remove existing vertices/faces based on view
    changes)
  * Methods that create new vertices/faces (that use this list of free
    vertices/faces in the original implementation) need to be overridden when
    the vdpm class is implemented.
  * All methods in the class that create a new face/vertex should call these
    new_*() methods so that the memory re-use can take place appropriately
    based on the specific type of the mesh object (i.e. pm vs vpm).

- Implemented GLMeshRenderer class
  * Base IRenderer interface now contains only one render() method that takes
    in no arguments. Necessary arguments for rendering should be stored as
    private members (possibly with getters/setters) in the implementing class.
  * GLMeshRenderer uses OpenGL's VBO for rendering (as in the latest
    implementation)
  * If the VBO needs to be updated (when the faces, etc. change), the user of
    the class/object must call the setter methods (for faces, vertices, etc.)
    then call set_update_vbo(true) before calling render().
  * It supports panning (x,y), rotation (x,y), and uniform scaling.
  * When the viewing parameters (bounding box and view frustum) needs to be
    changed (this happens when the set of vertices change completely, e.g. when
    a new mesh is loaded), the caller must call compute_view_parameters() after
    updating the vertices/faces/etc. respectively.

- TODO (in order):
  * Test the implementation (unit test, simulator, and device).
  * Implement view controller class - this will contain the touch screen
    related methods currently stored in the FirstTryViewController.mm file in
    the newest code, e.g. touchesBegan, touchesMoved, etc.
  * Implement vdpm class.
